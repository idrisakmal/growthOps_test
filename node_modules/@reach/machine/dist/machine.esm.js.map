{"version":3,"file":"machine.esm.js","sources":["../src/index.tsx"],"sourcesContent":["import { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\nimport {\n  assign,\n  createMachine,\n  EventObject as MachineEvent,\n  interpret,\n  InterpreterStatus,\n  StateMachine,\n  Typestate,\n} from \"@xstate/fsm\";\nimport { DistributiveOmit, isString, useConstant } from \"@reach/utils\";\n\nconst getServiceState = <\n  TContext extends object,\n  TEvent extends MachineEvent = MachineEvent,\n  TState extends Typestate<TContext> = any\n>(\n  service: StateMachine.Service<TContext, TEvent, TState>\n): StateMachine.State<TContext, TEvent, TState> => {\n  let currentValue: StateMachine.State<TContext, TEvent, TState>;\n  service\n    .subscribe((state) => {\n      currentValue = state;\n    })\n    .unsubscribe();\n  return currentValue!;\n};\n\n/**\n * This `useMachine` works very similiarly to what you get from `@xstate/react`\n * with some additions.\n *  - A second argument `refs` is passed to send all of our refs into our\n *    machine's contextual data object.\n *  - We wrap the `send` function so that refs are updated included in all of\n *    our events so we can use their current value (generally DOM nodes)\n *    anywhere in our actions.\n *  - We initialize the machine inside the component rather than throwing an\n *    error if an outside initializer creates a value that doesn't match. This\n *    is useful as some components may need a different initial state or some\n *    initial data based on props. We should *generally* just update the state\n *    with an event via useEffect and depend on a static initial value, but this\n *    is difficult if that initial value matters for SSR or to prevent some\n *    layout jank before the first paint. I don't think there's a problem with\n *    this approach, but we'll see what happens.\n *\n * @param initialMachine\n * @param refs\n */\nexport function useMachine<\n  TC extends object,\n  TE extends MachineEventWithRefs = MachineEventWithRefs,\n  TS extends Typestate<TC> = any\n>(\n  initialMachine: StateMachine.Machine<TC, TE, TS>,\n  refs: MachineToReactRefMap<TE>,\n  DEBUG?: boolean\n): [\n  Omit<StateMachine.State<TC, TE, TS>, \"actions\">,\n  StateMachine.Service<TC, DistributiveOmit<TE, \"refs\">>[\"send\"],\n  StateMachine.Service<TC, TE>\n] {\n  // State machine should not change between renders, so let's store it in a\n  // ref. This should also help if we need to use a creator function to inject\n  // dynamic initial state values based on props.\n  let machineRef = useRef(initialMachine);\n  let service = useConstant(() => interpret(machineRef.current).start());\n  let lastEventType = useRef<TE[\"type\"] | null>(null);\n\n  let [state, setState] = useState(() => getServiceState(service));\n\n  // This function reference will change on every render if we just pass on\n  // current.matches, but it shouldn't change unless the current value is\n  // updated. This was causing some lagginess when profiling in Listbox but\n  // is probably an issue everywhere since the parent components that handle\n  // state logic at the top might re-create context on each render as a\n  // result of this change.\n\n  // Add refs to every event so we can use them to perform actions.\n  let send = useCallback(\n    (rawEvent: TE[\"type\"] | DistributiveOmit<TE, \"refs\">) => {\n      let event = isString(rawEvent) ? { type: rawEvent } : rawEvent;\n      let refValues = unwrapRefs(refs);\n      service.send({\n        ...event,\n        lastEventType: lastEventType.current,\n        refs: refValues,\n      } as TE);\n      lastEventType.current = event.type;\n\n      if (__DEV__) {\n        if (DEBUG) {\n          console.group(\"Event Sent\");\n          console.log(\"Event:\", event);\n          console.groupEnd();\n        }\n      }\n    },\n    // We can disable the lint warning here. Refs will always be refs\n    // (TypeScript enforced!) and should not trigger a re-render. The state\n    // machine service persist for the life of the component.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [DEBUG]\n  );\n\n  useEffect(() => {\n    service.subscribe(function setStateIfChanged(newState) {\n      if (newState.changed) {\n        setState(newState);\n      }\n    });\n    return () => {\n      service.stop();\n    };\n  }, [service]);\n\n  useEffect(() => {\n    if (__DEV__) {\n      if (DEBUG && state.changed) {\n        console.group(\"State Updated\");\n        console.log(\"State:\", state);\n        console.groupEnd();\n      }\n    }\n  }, [DEBUG, state]);\n\n  // We are going to pass along our state without the actions to avoid excess\n  // renders when the reference changes. We haven't really needed them at this\n  // point, but if we do we can maybe reconsider this approach.\n  const memoizedState = useMemo(\n    () => ({\n      ...state,\n      matches: (value: any) => value === state.value,\n    }),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [state.changed, state.context, state.value]\n  );\n\n  return [memoizedState, send, service];\n}\n\n/**\n * Converts an object with React refs into an object with the same keys and\n * the current value of those refs.\n *\n * @param refs\n */\nexport function unwrapRefs<\n  TE extends MachineEventWithRefs = MachineEventWithRefs\n>(refs: MachineToReactRefMap<TE>): TE[\"refs\"] {\n  return Object.entries(refs).reduce((value, [name, ref]) => {\n    (value as any)[name] = ref.current;\n    return value;\n  }, {} as TE[\"refs\"]);\n}\n\n/**\n * Most of the time you want to create a static state machine outside of your\n * component, but in some cases we may need data from props in the first render\n * cycle. We can create our machine in each component IF we only create it once\n * and guarantee that it never changes between renders.\n *\n * This hook can take a machine definition created by a function inline to use\n * values defined in the component, and we never change the machine for the\n * life of the component.\n *\n * @param machineDefinition\n * @param options\n */\nexport function useCreateMachine<\n  TC extends object,\n  TE extends MachineEventWithRefs = MachineEventWithRefs,\n  TS extends Typestate<TC> = any\n>(\n  machineDefinition: StateMachine.Config<TC, TE, TS>,\n  options?: {\n    actions?: StateMachine.ActionMap<TC, TE>;\n  }\n): StateMachine.Machine<TC, TE, TS> {\n  return useConstant(() => createMachine(machineDefinition, options));\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Types\n\n/**\n * Events use in our `useMachine` always have a refs object and will inherit\n * this interface.\n */\nexport interface MachineEventWithRefs extends MachineEvent {\n  refs: {\n    [key: string]: any;\n  };\n  lastEventType?: MachineEventWithRefs[\"type\"];\n}\n\nexport type MachineToReactRefMap<TE extends MachineEventWithRefs> = {\n  [K in keyof TE[\"refs\"]]: React.RefObject<TE[\"refs\"][K]>;\n};\n\nexport type MachineState<\n  TC extends object,\n  TE extends MachineEventWithRefs = MachineEventWithRefs,\n  TS extends Typestate<TC> = any\n> = StateMachine.State<TC, TE, TS>;\n\nexport type MachineSend<\n  TC extends object,\n  TE extends MachineEventWithRefs = MachineEventWithRefs\n> = StateMachine.Service<TC, DistributiveOmit<TE, \"refs\">>[\"send\"];\n\nexport type MachineService<\n  TC extends object,\n  TE extends MachineEventWithRefs = MachineEventWithRefs\n> = StateMachine.Service<TC, TE>;\n\n// Export types and functions from xstate/fsm\nexport { InterpreterStatus, MachineEvent, StateMachine };\nexport { createMachine, assign, interpret };\n"],"names":["getServiceState","service","currentValue","subscribe","state","unsubscribe","useMachine","initialMachine","refs","DEBUG","machineRef","useRef","useConstant","interpret","current","start","lastEventType","useState","setState","send","useCallback","rawEvent","event","isString","type","refValues","unwrapRefs","console","group","log","groupEnd","useEffect","setStateIfChanged","newState","changed","stop","memoizedState","useMemo","matches","value","context","Object","entries","reduce","name","ref","useCreateMachine","machineDefinition","options","createMachine"],"mappings":"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"}