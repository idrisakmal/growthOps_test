{"version":3,"file":"machine.cjs.production.min.js","sources":["../src/index.tsx"],"sourcesContent":["import { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\nimport {\n  assign,\n  createMachine,\n  EventObject as MachineEvent,\n  interpret,\n  InterpreterStatus,\n  StateMachine,\n  Typestate,\n} from \"@xstate/fsm\";\nimport { DistributiveOmit, isString, useConstant } from \"@reach/utils\";\n\nconst getServiceState = <\n  TContext extends object,\n  TEvent extends MachineEvent = MachineEvent,\n  TState extends Typestate<TContext> = any\n>(\n  service: StateMachine.Service<TContext, TEvent, TState>\n): StateMachine.State<TContext, TEvent, TState> => {\n  let currentValue: StateMachine.State<TContext, TEvent, TState>;\n  service\n    .subscribe((state) => {\n      currentValue = state;\n    })\n    .unsubscribe();\n  return currentValue!;\n};\n\n/**\n * This `useMachine` works very similiarly to what you get from `@xstate/react`\n * with some additions.\n *  - A second argument `refs` is passed to send all of our refs into our\n *    machine's contextual data object.\n *  - We wrap the `send` function so that refs are updated included in all of\n *    our events so we can use their current value (generally DOM nodes)\n *    anywhere in our actions.\n *  - We initialize the machine inside the component rather than throwing an\n *    error if an outside initializer creates a value that doesn't match. This\n *    is useful as some components may need a different initial state or some\n *    initial data based on props. We should *generally* just update the state\n *    with an event via useEffect and depend on a static initial value, but this\n *    is difficult if that initial value matters for SSR or to prevent some\n *    layout jank before the first paint. I don't think there's a problem with\n *    this approach, but we'll see what happens.\n *\n * @param initialMachine\n * @param refs\n */\nexport function useMachine<\n  TC extends object,\n  TE extends MachineEventWithRefs = MachineEventWithRefs,\n  TS extends Typestate<TC> = any\n>(\n  initialMachine: StateMachine.Machine<TC, TE, TS>,\n  refs: MachineToReactRefMap<TE>,\n  DEBUG?: boolean\n): [\n  Omit<StateMachine.State<TC, TE, TS>, \"actions\">,\n  StateMachine.Service<TC, DistributiveOmit<TE, \"refs\">>[\"send\"],\n  StateMachine.Service<TC, TE>\n] {\n  // State machine should not change between renders, so let's store it in a\n  // ref. This should also help if we need to use a creator function to inject\n  // dynamic initial state values based on props.\n  let machineRef = useRef(initialMachine);\n  let service = useConstant(() => interpret(machineRef.current).start());\n  let lastEventType = useRef<TE[\"type\"] | null>(null);\n\n  let [state, setState] = useState(() => getServiceState(service));\n\n  // This function reference will change on every render if we just pass on\n  // current.matches, but it shouldn't change unless the current value is\n  // updated. This was causing some lagginess when profiling in Listbox but\n  // is probably an issue everywhere since the parent components that handle\n  // state logic at the top might re-create context on each render as a\n  // result of this change.\n\n  // Add refs to every event so we can use them to perform actions.\n  let send = useCallback(\n    (rawEvent: TE[\"type\"] | DistributiveOmit<TE, \"refs\">) => {\n      let event = isString(rawEvent) ? { type: rawEvent } : rawEvent;\n      let refValues = unwrapRefs(refs);\n      service.send({\n        ...event,\n        lastEventType: lastEventType.current,\n        refs: refValues,\n      } as TE);\n      lastEventType.current = event.type;\n\n      if (__DEV__) {\n        if (DEBUG) {\n          console.group(\"Event Sent\");\n          console.log(\"Event:\", event);\n          console.groupEnd();\n        }\n      }\n    },\n    // We can disable the lint warning here. Refs will always be refs\n    // (TypeScript enforced!) and should not trigger a re-render. The state\n    // machine service persist for the life of the component.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [DEBUG]\n  );\n\n  useEffect(() => {\n    service.subscribe(function setStateIfChanged(newState) {\n      if (newState.changed) {\n        setState(newState);\n      }\n    });\n    return () => {\n      service.stop();\n    };\n  }, [service]);\n\n  useEffect(() => {\n    if (__DEV__) {\n      if (DEBUG && state.changed) {\n        console.group(\"State Updated\");\n        console.log(\"State:\", state);\n        console.groupEnd();\n      }\n    }\n  }, [DEBUG, state]);\n\n  // We are going to pass along our state without the actions to avoid excess\n  // renders when the reference changes. We haven't really needed them at this\n  // point, but if we do we can maybe reconsider this approach.\n  const memoizedState = useMemo(\n    () => ({\n      ...state,\n      matches: (value: any) => value === state.value,\n    }),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [state.changed, state.context, state.value]\n  );\n\n  return [memoizedState, send, service];\n}\n\n/**\n * Converts an object with React refs into an object with the same keys and\n * the current value of those refs.\n *\n * @param refs\n */\nexport function unwrapRefs<\n  TE extends MachineEventWithRefs = MachineEventWithRefs\n>(refs: MachineToReactRefMap<TE>): TE[\"refs\"] {\n  return Object.entries(refs).reduce((value, [name, ref]) => {\n    (value as any)[name] = ref.current;\n    return value;\n  }, {} as TE[\"refs\"]);\n}\n\n/**\n * Most of the time you want to create a static state machine outside of your\n * component, but in some cases we may need data from props in the first render\n * cycle. We can create our machine in each component IF we only create it once\n * and guarantee that it never changes between renders.\n *\n * This hook can take a machine definition created by a function inline to use\n * values defined in the component, and we never change the machine for the\n * life of the component.\n *\n * @param machineDefinition\n * @param options\n */\nexport function useCreateMachine<\n  TC extends object,\n  TE extends MachineEventWithRefs = MachineEventWithRefs,\n  TS extends Typestate<TC> = any\n>(\n  machineDefinition: StateMachine.Config<TC, TE, TS>,\n  options?: {\n    actions?: StateMachine.ActionMap<TC, TE>;\n  }\n): StateMachine.Machine<TC, TE, TS> {\n  return useConstant(() => createMachine(machineDefinition, options));\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Types\n\n/**\n * Events use in our `useMachine` always have a refs object and will inherit\n * this interface.\n */\nexport interface MachineEventWithRefs extends MachineEvent {\n  refs: {\n    [key: string]: any;\n  };\n  lastEventType?: MachineEventWithRefs[\"type\"];\n}\n\nexport type MachineToReactRefMap<TE extends MachineEventWithRefs> = {\n  [K in keyof TE[\"refs\"]]: React.RefObject<TE[\"refs\"][K]>;\n};\n\nexport type MachineState<\n  TC extends object,\n  TE extends MachineEventWithRefs = MachineEventWithRefs,\n  TS extends Typestate<TC> = any\n> = StateMachine.State<TC, TE, TS>;\n\nexport type MachineSend<\n  TC extends object,\n  TE extends MachineEventWithRefs = MachineEventWithRefs\n> = StateMachine.Service<TC, DistributiveOmit<TE, \"refs\">>[\"send\"];\n\nexport type MachineService<\n  TC extends object,\n  TE extends MachineEventWithRefs = MachineEventWithRefs\n> = StateMachine.Service<TC, TE>;\n\n// Export types and functions from xstate/fsm\nexport { InterpreterStatus, MachineEvent, StateMachine };\nexport { createMachine, assign, interpret };\n"],"names":["unwrapRefs","refs","Object","entries","reduce","value","current","machineDefinition","options","useConstant","createMachine","initialMachine","DEBUG","machineRef","useRef","service","interpret","start","lastEventType","useState","currentValue","subscribe","state","unsubscribe","getServiceState","setState","send","useCallback","rawEvent","event","isString","type","refValues","useEffect","newState","changed","stop","useMemo","matches","context"],"mappings":"sWAkJgBA,EAEdC,UACOC,OAAOC,QAAQF,GAAMG,QAAO,SAACC,YACjCA,aAA0BC,QACpBD,IACN,qcAqBHE,EACAC,UAIOC,eAAY,kBAAMC,gBAAcH,EAAmBC,mCA7H1DG,EACAV,EACAW,OASIC,EAAaC,SAAOH,GACpBI,EAAUN,eAAY,kBAAMO,YAAUH,EAAWP,SAASW,WAC1DC,EAAgBJ,SAA0B,QAEtBK,YAAS,kBAxDX,SAKtBJ,OAEIK,SACJL,EACGM,WAAU,SAACC,GACVF,EAAeE,KAEhBC,cACIH,EA2CgCI,CAAgBT,MAAlDO,OAAOG,OAURC,EAAOC,eACT,SAACC,OACKC,EAAQC,WAASF,GAAY,CAAEG,KAAMH,GAAaA,EAClDI,EAAYhC,EAAWC,GAC3Bc,EAAQW,UACHG,GACHX,cAAeA,EAAcZ,QAC7BL,KAAM+B,KAERd,EAAcZ,QAAUuB,EAAME,QAc/BnB,WAGHqB,aAAU,kBACRlB,EAAQM,WAAU,SAA2Ba,GACvCA,EAASC,SACXV,EAASS,MAGN,WACLnB,EAAQqB,UAET,CAACrB,IAEJkB,aAAU,cAQP,CAACrB,EAAOU,IAcJ,CATee,WACpB,uBACKf,GACHgB,QAAS,SAACjC,UAAeA,IAAUiB,EAAMjB,YAG1CiB,EAAMa,QAASb,EAAMiB,QAASjB,EAAMjB,QAGhBqB,EAAMX"}