import React, { forwardRef, useRef, useMemo, useEffect, Fragment, memo, useContext, useState, useCallback } from 'react';
import PropTypes from 'prop-types';
import { useId } from '@reach/auto-id';
import Popover, { positionMatchWidth } from '@reach/popover';
import { useDescendantsInit, DescendantProvider, useDescendant, createDescendantContext, useDescendants, useDescendantKeyDown } from '@reach/descendants';
import { getOwnerDocument, useCallbackProp, makeId, useForkedRef, useControlledSwitchWarning, useIsomorphicLayoutEffect, useCheckStyles, isFunction, memoWithAs, forwardRefWithAs, wrapEvent, createNamedContext, isBoolean, isRightClick, isString } from '@reach/utils';
import { assign, useCreateMachine, useMachine } from '@reach/machine';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var _commonEvents;
// States

var ListboxStates;

(function (ListboxStates) {
  // Resting/closed state.
  ListboxStates["Idle"] = "IDLE"; // Listbox is open but the user is not yet navigating.

  ListboxStates["Open"] = "OPEN"; // The user is navigating the list

  ListboxStates["Navigating"] = "NAVIGATING"; // The user has moused-down but hasn't made a selection yet

  ListboxStates["Dragging"] = "DRAGGING"; // The user is interacting with arbitrary elements inside the popover

  ListboxStates["Interacting"] = "INTERACTING";
})(ListboxStates || (ListboxStates = {})); ////////////////////////////////////////////////////////////////////////////////
// Events


var ListboxEvents;

(function (ListboxEvents) {
  ListboxEvents["ButtonMouseDown"] = "BUTTON_MOUSE_DOWN";
  ListboxEvents["ButtonMouseUp"] = "BUTTON_MOUSE_UP";
  ListboxEvents["Blur"] = "BLUR";
  ListboxEvents["ClearNavSelection"] = "CLEAR_NAV_SELECTION";
  ListboxEvents["ClearTypeahead"] = "CLEAR_TYPEAHEAD";
  ListboxEvents["GetDerivedData"] = "GET_DERIVED_DATA";
  ListboxEvents["KeyDownEscape"] = "KEY_DOWN_ESCAPE";
  ListboxEvents["KeyDownEnter"] = "KEY_DOWN_ENTER";
  ListboxEvents["KeyDownSpace"] = "KEY_DOWN_SPACE";
  ListboxEvents["KeyDownNavigate"] = "KEY_DOWN_NAVIGATE";
  ListboxEvents["KeyDownSearch"] = "KEY_DOWN_SEARCH";
  ListboxEvents["KeyDownTab"] = "KEY_DOWN_TAB";
  ListboxEvents["KeyDownShiftTab"] = "KEY_DOWN_SHIFT_TAB";
  ListboxEvents["OptionTouchStart"] = "OPTION_TOUCH_START";
  ListboxEvents["OptionMouseMove"] = "OPTION_MOUSE_MOVE";
  ListboxEvents["OptionMouseEnter"] = "OPTION_MOUSE_ENTER";
  ListboxEvents["OutsideMouseDown"] = "OUTSIDE_MOUSE_DOWN";
  ListboxEvents["OutsideMouseUp"] = "OUTSIDE_MOUSE_UP"; // Uncontrolled value changes come from specific events (click, key, etc.)
  // ValueChange > Value change may have come from somewhere else

  ListboxEvents["ValueChange"] = "VALUE_CHANGE";
  ListboxEvents["OptionMouseDown"] = "OPTION_MOUSE_DOWN";
  ListboxEvents["OptionMouseUp"] = "OPTION_MOUSE_UP";
  ListboxEvents["PopoverPointerDown"] = "POPOVER_POINTER_DOWN";
  ListboxEvents["PopoverPointerUp"] = "POPOVER_POINTER_UP";
  ListboxEvents["UpdateAfterTypeahead"] = "UPDATE_AFTER_TYPEAHEAD";
})(ListboxEvents || (ListboxEvents = {})); ////////////////////////////////////////////////////////////////////////////////
// Actions and conditions


var clearNavigationValue = /*#__PURE__*/assign({
  navigationValue: null
});
var clearTypeahead = /*#__PURE__*/assign({
  typeaheadQuery: null
});
var assignValue = /*#__PURE__*/assign({
  value: function value(_, event) {
    return event.value;
  }
});
var navigate = /*#__PURE__*/assign({
  navigationValue: function navigationValue(data, event) {
    return event.value;
  }
});
var navigateFromCurrentValue = /*#__PURE__*/assign({
  navigationValue: function navigationValue(data) {
    // Before we navigate based on the current value, we need to make sure the
    // current value is selectable. If not, we should instead navigate to the
    // first selectable option.
    var selected = findOptionFromValue(data.value, data.options);

    if (selected && !selected.disabled) {
      return data.value;
    } else {
      var _data$options$find;

      return ((_data$options$find = data.options.find(function (option) {
        return !option.disabled;
      })) === null || _data$options$find === void 0 ? void 0 : _data$options$find.value) || null;
    }
  }
});

function listboxLostFocus(data, event) {
  if (event.type === ListboxEvents.Blur) {
    var _event$refs = event.refs,
        list = _event$refs.list,
        popover = _event$refs.popover;
    var relatedTarget = event.relatedTarget;
    var ownerDocument = popover && getOwnerDocument(popover) || document;
    return !!(ownerDocument.activeElement !== list && popover && !popover.contains(relatedTarget || ownerDocument.activeElement));
  }

  return false;
}

function clickedOutsideOfListbox(data, event) {
  if (event.type === ListboxEvents.OutsideMouseDown || event.type === ListboxEvents.OutsideMouseUp) {
    var _event$refs2 = event.refs,
        button = _event$refs2.button,
        popover = _event$refs2.popover;
    var relatedTarget = event.relatedTarget; // Close the popover IF:

    return !!( // clicked element is not the button
    relatedTarget !== button && // clicked element is not inside the button
    button && !button.contains(relatedTarget) && // clicked element is not inside the popover
    popover && !popover.contains(relatedTarget));
  }

  return false;
}

function optionIsActive(data, event) {
  return !!data.options.find(function (option) {
    return option.value === data.navigationValue;
  });
}

function shouldNavigate(data, event) {
  var _event$refs3 = event.refs,
      popover = _event$refs3.popover,
      list = _event$refs3.list;
  var relatedTarget = event.relatedTarget; // When a blur event happens, we want to move to Navigating state unless the
  // user is interacting with elements inside the popover...

  if (popover && relatedTarget && popover.contains(relatedTarget) && relatedTarget !== list) {
    return false;
  } // ...otherwise, just make sure the next option is selectable


  return optionIsActive(data);
}

function focusList(data, event) {
  requestAnimationFrame(function () {
    event.refs.list && event.refs.list.focus();
  });
}

function focusButton(data, event) {
  event.refs.button && event.refs.button.focus();
}

function listboxIsNotDisabled(data, event) {
  return !event.disabled;
}

function optionIsNavigable(data, event) {
  if (event.type === ListboxEvents.OptionTouchStart) {
    if (event && event.disabled) {
      return false;
    }
  }

  return true;
}

function optionIsSelectable(data, event) {
  if (event && event.disabled) {
    return false;
  }

  return data.navigationValue != null;
}

function selectOption(data, event) {
  event.callback && event.callback(event.value);
}

function submitForm(data, event) {
  if (event.type !== ListboxEvents.KeyDownEnter) {
    return;
  } // So this one is a little weird, but here's what we're doing.
  // When a user presses Enter in the context of a form, the form
  // should submit. Now I know you're probably thinking:
  //
  //      "Aha! I've got it!"
  //          > inputNode.form.submit()
  //      ** cracks knuckles ** "Phew. My work here is done."
  //
  // But alas, we are not so lucky. What's really happening when a
  // user presses enter in a normal form field is that the browser
  // looks at the form the input is in, then looks for the first
  // button or input in that form where its type property is `submit`,
  // then it triggers a click event on that button. COOL, CARRY ON.
  //
  // If we were to fire inputNode.form.submit(), this would bypass any
  // onSubmit handler in the form and just do what the browser
  // normally does when you submit a form and trigger a page refresh.
  // No bueno. So we do what the browser does and just go on a duck
  // hunt for the first submit button in the form and we click that
  // sucker.


  var hiddenInput = event.refs.hiddenInput;

  if (hiddenInput && hiddenInput.form) {
    var submitButton = hiddenInput.form.querySelector("button,[type='submit']");
    submitButton && submitButton.click();
  }
}

var setTypeahead = /*#__PURE__*/assign({
  typeaheadQuery: function typeaheadQuery(data, event) {
    return (data.typeaheadQuery || "") + event.query;
  }
});
var setValueFromTypeahead = /*#__PURE__*/assign({
  value: function value(data, event) {
    if (event.type === ListboxEvents.UpdateAfterTypeahead && event.query) {
      var match = findOptionFromTypeahead(data.options, event.query);

      if (match && !match.disabled) {
        event.callback && event.callback(match.value);
        return match.value;
      }
    }

    return data.value;
  }
});
var setNavSelectionFromTypeahead = /*#__PURE__*/assign({
  navigationValue: function navigationValue(data, event) {
    if (event.type === ListboxEvents.UpdateAfterTypeahead && event.query) {
      var match = findOptionFromTypeahead(data.options, event.query);

      if (match && !match.disabled) {
        return match.value;
      }
    }

    return data.navigationValue;
  }
});
var commonEvents = (_commonEvents = {}, _commonEvents[ListboxEvents.GetDerivedData] = {
  actions: /*#__PURE__*/assign(function (ctx, event) {
    return _extends({}, ctx, event.data);
  })
}, _commonEvents[ListboxEvents.ValueChange] = {
  actions: [assignValue, selectOption]
}, _commonEvents); ////////////////////////////////////////////////////////////////////////////////

/**
 * Initializer for our state machine.
 *
 * @param initial
 * @param props
 */

var createMachineDefinition = function createMachineDefinition(_ref) {
  var _extends2, _extends3, _extends4, _extends5, _extends6, _states;

  var value = _ref.value;
  return {
    id: "listbox",
    initial: ListboxStates.Idle,
    context: {
      value: value,
      options: [],
      navigationValue: null,
      typeaheadQuery: null
    },
    states: (_states = {}, _states[ListboxStates.Idle] = {
      on: _extends({}, commonEvents, (_extends2 = {}, _extends2[ListboxEvents.ButtonMouseDown] = {
        target: ListboxStates.Open,
        actions: [navigateFromCurrentValue],
        cond: listboxIsNotDisabled
      }, _extends2[ListboxEvents.KeyDownSpace] = {
        target: ListboxStates.Navigating,
        actions: [navigateFromCurrentValue, focusList],
        cond: listboxIsNotDisabled
      }, _extends2[ListboxEvents.KeyDownSearch] = {
        target: ListboxStates.Idle,
        actions: setTypeahead,
        cond: listboxIsNotDisabled
      }, _extends2[ListboxEvents.UpdateAfterTypeahead] = {
        target: ListboxStates.Idle,
        actions: [setValueFromTypeahead],
        cond: listboxIsNotDisabled
      }, _extends2[ListboxEvents.ClearTypeahead] = {
        target: ListboxStates.Idle,
        actions: clearTypeahead
      }, _extends2[ListboxEvents.KeyDownNavigate] = {
        target: ListboxStates.Navigating,
        actions: [navigateFromCurrentValue, clearTypeahead, focusList],
        cond: listboxIsNotDisabled
      }, _extends2[ListboxEvents.KeyDownEnter] = {
        actions: [submitForm],
        cond: listboxIsNotDisabled
      }, _extends2))
    }, _states[ListboxStates.Interacting] = {
      entry: [clearNavigationValue],
      on: _extends({}, commonEvents, (_extends3 = {}, _extends3[ListboxEvents.ClearNavSelection] = {
        actions: [clearNavigationValue, focusList]
      }, _extends3[ListboxEvents.KeyDownEnter] = {
        target: ListboxStates.Idle,
        actions: [assignValue, clearTypeahead, focusButton, selectOption],
        cond: optionIsSelectable
      }, _extends3[ListboxEvents.KeyDownSpace] = {
        target: ListboxStates.Idle,
        actions: [assignValue, clearTypeahead, focusButton, selectOption],
        cond: optionIsSelectable
      }, _extends3[ListboxEvents.ButtonMouseDown] = {
        target: ListboxStates.Idle,
        // When the user triggers a mouseDown event on the button, we call
        // event.preventDefault() because the browser will naturally send a
        // mouseup event and click, which will reopen the button (which we
        // don't want). As such, the click won't blur the open list or
        // re-focus the trigger, so we call `focusButton` to do that manually.
        // We could work around this with deferred transitions with xstate,
        // but @xstate/fsm currently doesn't support that feature and this
        // works good enough for the moment.
        actions: [focusButton]
      }, _extends3[ListboxEvents.KeyDownEscape] = {
        target: ListboxStates.Idle,
        actions: [focusButton]
      }, _extends3[ListboxEvents.OptionMouseDown] = {
        target: ListboxStates.Dragging
      }, _extends3[ListboxEvents.OutsideMouseDown] = [{
        target: ListboxStates.Idle,
        cond: clickedOutsideOfListbox,
        actions: clearTypeahead
      }, {
        target: ListboxStates.Dragging,
        actions: clearTypeahead,
        cond: optionIsActive
      }], _extends3[ListboxEvents.OutsideMouseUp] = [{
        target: ListboxStates.Idle,
        cond: clickedOutsideOfListbox,
        actions: clearTypeahead
      }, {
        target: ListboxStates.Navigating,
        cond: optionIsActive
      }, {
        target: ListboxStates.Interacting,
        actions: clearTypeahead
      }], _extends3[ListboxEvents.KeyDownEnter] = ListboxStates.Interacting, _extends3[ListboxEvents.Blur] = [{
        target: ListboxStates.Idle,
        cond: listboxLostFocus,
        actions: clearTypeahead
      }, {
        target: ListboxStates.Navigating,
        cond: shouldNavigate
      }, {
        target: ListboxStates.Interacting,
        actions: clearTypeahead
      }], _extends3[ListboxEvents.OptionTouchStart] = {
        target: ListboxStates.Navigating,
        actions: [navigate, clearTypeahead],
        cond: optionIsNavigable
      }, _extends3[ListboxEvents.OptionMouseEnter] = {
        target: ListboxStates.Navigating,
        actions: [navigate, clearTypeahead],
        cond: optionIsNavigable
      }, _extends3[ListboxEvents.KeyDownNavigate] = {
        target: ListboxStates.Navigating,
        actions: [navigate, clearTypeahead, focusList]
      }, _extends3))
    }, _states[ListboxStates.Open] = {
      on: _extends({}, commonEvents, (_extends4 = {}, _extends4[ListboxEvents.ClearNavSelection] = {
        actions: [clearNavigationValue]
      }, _extends4[ListboxEvents.KeyDownEnter] = {
        target: ListboxStates.Idle,
        actions: [assignValue, clearTypeahead, focusButton, selectOption],
        cond: optionIsSelectable
      }, _extends4[ListboxEvents.KeyDownSpace] = {
        target: ListboxStates.Idle,
        actions: [assignValue, clearTypeahead, focusButton, selectOption],
        cond: optionIsSelectable
      }, _extends4[ListboxEvents.ButtonMouseDown] = {
        target: ListboxStates.Idle,
        actions: [focusButton]
      }, _extends4[ListboxEvents.KeyDownEscape] = {
        target: ListboxStates.Idle,
        actions: [focusButton]
      }, _extends4[ListboxEvents.OptionMouseDown] = {
        target: ListboxStates.Dragging
      }, _extends4[ListboxEvents.OutsideMouseDown] = [{
        target: ListboxStates.Idle,
        cond: clickedOutsideOfListbox,
        actions: clearTypeahead
      }, {
        target: ListboxStates.Dragging,
        cond: optionIsActive
      }, {
        target: ListboxStates.Interacting,
        actions: clearTypeahead
      }], _extends4[ListboxEvents.OutsideMouseUp] = [{
        target: ListboxStates.Idle,
        cond: clickedOutsideOfListbox,
        actions: clearTypeahead
      }, {
        target: ListboxStates.Navigating,
        cond: optionIsActive
      }, {
        target: ListboxStates.Interacting,
        actions: clearTypeahead
      }], _extends4[ListboxEvents.Blur] = [{
        target: ListboxStates.Idle,
        cond: listboxLostFocus,
        actions: clearTypeahead
      }, {
        target: ListboxStates.Navigating,
        cond: shouldNavigate
      }, {
        target: ListboxStates.Interacting,
        actions: clearTypeahead
      }], _extends4[ListboxEvents.ButtonMouseUp] = {
        target: ListboxStates.Navigating,
        actions: [navigateFromCurrentValue, focusList]
      }, _extends4[ListboxEvents.OptionTouchStart] = {
        target: ListboxStates.Navigating,
        actions: [navigate, clearTypeahead],
        cond: optionIsNavigable
      }, _extends4[ListboxEvents.KeyDownNavigate] = {
        target: ListboxStates.Navigating,
        actions: [navigate, clearTypeahead, focusList]
      }, _extends4[ListboxEvents.KeyDownSearch] = {
        target: ListboxStates.Navigating,
        actions: setTypeahead
      }, _extends4[ListboxEvents.UpdateAfterTypeahead] = {
        actions: [setNavSelectionFromTypeahead]
      }, _extends4[ListboxEvents.ClearTypeahead] = {
        actions: clearTypeahead
      }, _extends4[ListboxEvents.OptionMouseMove] = [{
        target: ListboxStates.Dragging,
        actions: [navigate],
        cond: optionIsNavigable
      }, {
        target: ListboxStates.Dragging
      }], _extends4))
    }, _states[ListboxStates.Dragging] = {
      on: _extends({}, commonEvents, (_extends5 = {}, _extends5[ListboxEvents.ClearNavSelection] = {
        actions: [clearNavigationValue]
      }, _extends5[ListboxEvents.KeyDownEnter] = {
        target: ListboxStates.Idle,
        actions: [assignValue, clearTypeahead, focusButton, selectOption],
        cond: optionIsSelectable
      }, _extends5[ListboxEvents.KeyDownSpace] = {
        target: ListboxStates.Idle,
        actions: [assignValue, clearTypeahead, focusButton, selectOption],
        cond: optionIsSelectable
      }, _extends5[ListboxEvents.ButtonMouseDown] = {
        target: ListboxStates.Idle,
        actions: [focusButton]
      }, _extends5[ListboxEvents.KeyDownEscape] = {
        target: ListboxStates.Idle,
        actions: [focusButton]
      }, _extends5[ListboxEvents.OptionMouseDown] = {
        target: ListboxStates.Dragging
      }, _extends5[ListboxEvents.OutsideMouseDown] = [{
        target: ListboxStates.Idle,
        cond: clickedOutsideOfListbox,
        actions: clearTypeahead
      }, {
        target: ListboxStates.Navigating,
        cond: optionIsActive
      }, {
        target: ListboxStates.Interacting,
        actions: clearTypeahead
      }], _extends5[ListboxEvents.OutsideMouseUp] = [{
        target: ListboxStates.Idle,
        cond: clickedOutsideOfListbox,
        actions: clearTypeahead
      }, {
        target: ListboxStates.Navigating,
        cond: optionIsActive,
        actions: focusList
      }, {
        target: ListboxStates.Interacting,
        actions: [clearTypeahead, focusList]
      }], _extends5[ListboxEvents.Blur] = [{
        target: ListboxStates.Idle,
        cond: listboxLostFocus,
        actions: clearTypeahead
      }, {
        target: ListboxStates.Navigating,
        cond: shouldNavigate
      }, {
        target: ListboxStates.Interacting,
        actions: clearTypeahead
      }], _extends5[ListboxEvents.ButtonMouseUp] = {
        target: ListboxStates.Navigating,
        actions: [navigateFromCurrentValue, focusList]
      }, _extends5[ListboxEvents.OptionTouchStart] = {
        target: ListboxStates.Navigating,
        actions: [navigate, clearTypeahead],
        cond: optionIsNavigable
      }, _extends5[ListboxEvents.OptionMouseEnter] = {
        target: ListboxStates.Dragging,
        actions: [navigate, clearTypeahead],
        cond: optionIsNavigable
      }, _extends5[ListboxEvents.KeyDownNavigate] = {
        target: ListboxStates.Navigating,
        actions: [navigate, clearTypeahead, focusList]
      }, _extends5[ListboxEvents.KeyDownSearch] = {
        target: ListboxStates.Navigating,
        actions: setTypeahead
      }, _extends5[ListboxEvents.UpdateAfterTypeahead] = {
        actions: [setNavSelectionFromTypeahead]
      }, _extends5[ListboxEvents.ClearTypeahead] = {
        actions: clearTypeahead
      }, _extends5[ListboxEvents.OptionMouseMove] = [{
        target: ListboxStates.Navigating,
        actions: [navigate],
        cond: optionIsNavigable
      }, {
        target: ListboxStates.Navigating
      }], _extends5[ListboxEvents.OptionMouseUp] = {
        target: ListboxStates.Idle,
        actions: [assignValue, clearTypeahead, focusButton, selectOption],
        cond: optionIsSelectable
      }, _extends5))
    }, _states[ListboxStates.Navigating] = {
      on: _extends({}, commonEvents, (_extends6 = {}, _extends6[ListboxEvents.ClearNavSelection] = {
        actions: [clearNavigationValue, focusList]
      }, _extends6[ListboxEvents.KeyDownEnter] = {
        target: ListboxStates.Idle,
        actions: [assignValue, clearTypeahead, focusButton, selectOption],
        cond: optionIsSelectable
      }, _extends6[ListboxEvents.KeyDownSpace] = {
        target: ListboxStates.Idle,
        actions: [assignValue, clearTypeahead, focusButton, selectOption],
        cond: optionIsSelectable
      }, _extends6[ListboxEvents.ButtonMouseDown] = {
        target: ListboxStates.Idle,
        actions: [focusButton]
      }, _extends6[ListboxEvents.KeyDownEscape] = {
        target: ListboxStates.Idle,
        actions: [focusButton]
      }, _extends6[ListboxEvents.OptionMouseDown] = {
        target: ListboxStates.Dragging
      }, _extends6[ListboxEvents.OutsideMouseDown] = [{
        target: ListboxStates.Idle,
        cond: clickedOutsideOfListbox,
        actions: clearTypeahead
      }, {
        target: ListboxStates.Navigating,
        cond: optionIsActive
      }, {
        target: ListboxStates.Interacting,
        actions: clearTypeahead
      }], _extends6[ListboxEvents.OutsideMouseUp] = [{
        target: ListboxStates.Idle,
        cond: clickedOutsideOfListbox,
        actions: clearTypeahead
      }, {
        target: ListboxStates.Navigating,
        cond: optionIsActive
      }, {
        target: ListboxStates.Interacting,
        actions: clearTypeahead
      }], _extends6[ListboxEvents.Blur] = [{
        target: ListboxStates.Idle,
        cond: listboxLostFocus,
        actions: clearTypeahead
      }, {
        target: ListboxStates.Navigating,
        cond: shouldNavigate
      }, {
        target: ListboxStates.Interacting,
        actions: clearTypeahead
      }], _extends6[ListboxEvents.ButtonMouseUp] = {
        target: ListboxStates.Navigating,
        actions: [navigateFromCurrentValue, focusList]
      }, _extends6[ListboxEvents.OptionTouchStart] = {
        target: ListboxStates.Navigating,
        actions: [navigate, clearTypeahead],
        cond: optionIsNavigable
      }, _extends6[ListboxEvents.OptionMouseEnter] = {
        target: ListboxStates.Navigating,
        actions: [navigate, clearTypeahead],
        cond: optionIsNavigable
      }, _extends6[ListboxEvents.KeyDownNavigate] = {
        target: ListboxStates.Navigating,
        actions: [navigate, clearTypeahead, focusList]
      }, _extends6[ListboxEvents.KeyDownSearch] = {
        target: ListboxStates.Navigating,
        actions: setTypeahead
      }, _extends6[ListboxEvents.UpdateAfterTypeahead] = {
        actions: [setNavSelectionFromTypeahead]
      }, _extends6[ListboxEvents.ClearTypeahead] = {
        actions: clearTypeahead
      }, _extends6[ListboxEvents.OptionMouseMove] = [{
        target: ListboxStates.Navigating,
        actions: [navigate],
        cond: optionIsNavigable
      }, {
        target: ListboxStates.Navigating
      }], _extends6))
    }, _states)
  };
}; ////////////////////////////////////////////////////////////////////////////////

function findOptionFromTypeahead(options, string) {
  if (string === void 0) {
    string = "";
  }

  if (!string) return null;
  var found = options.find(function (option) {
    return !option.disabled && option.label && option.label.toLowerCase().startsWith(string.toLowerCase());
  });
  return found || null;
}

function findOptionFromValue(value, options) {
  return value ? options.find(function (option) {
    return option.value === value;
  }) : undefined;
}

var DEBUG = false; ////////////////////////////////////////////////////////////////////////////////
// ListboxContext

var ListboxDescendantContext = /*#__PURE__*/createDescendantContext("ListboxDescendantContext");
var ListboxContext = /*#__PURE__*/createNamedContext("ListboxContext", {});
var ListboxGroupContext = /*#__PURE__*/createNamedContext("ListboxGroupContext", {}); ////////////////////////////////////////////////////////////////////////////////

/**
 * ListboxInput
 *
 * The top-level component and context provider for the listbox.
 *
 * @see Docs https://reach.tech/listbox#listboxinput
 */

var ListboxInput = /*#__PURE__*/forwardRef(function ListboxInput(_ref, forwardedRef) {
  var ariaLabelledBy = _ref["aria-labelledby"],
      ariaLabel = _ref["aria-label"],
      children = _ref.children,
      defaultValue = _ref.defaultValue,
      _ref$disabled = _ref.disabled,
      disabled = _ref$disabled === void 0 ? false : _ref$disabled,
      form = _ref.form,
      name = _ref.name,
      onChangeProp = _ref.onChange,
      required = _ref.required,
      valueProp = _ref.value,
      _ref$_componentName = _ref._componentName,
      _componentName = _ref$_componentName === void 0 ? "ListboxInput" : _ref$_componentName,
      props = _objectWithoutPropertiesLoose(_ref, ["aria-labelledby", "aria-label", "children", "defaultValue", "disabled", "form", "name", "onChange", "required", "value", "_componentName"]);

  var isControlled = useRef(valueProp != null);

  var _useDescendantsInit = useDescendantsInit(),
      options = _useDescendantsInit[0],
      setOptions = _useDescendantsInit[1];

  var onChange = useCallbackProp(onChangeProp); // DOM refs

  var buttonRef = useRef(null);
  var hiddenInputRef = useRef(null);
  var highlightedOptionRef = useRef(null);
  var inputRef = useRef(null);
  var listRef = useRef(null);
  var popoverRef = useRef(null);
  var selectedOptionRef = useRef(null);
  var machine = useCreateMachine(createMachineDefinition({
    // The initial value of our machine should come from the `value` or
    // `defaultValue` props if they exist.
    value: (isControlled.current ? valueProp : defaultValue) || null
  }));

  var _useMachine = useMachine(machine, {
    button: buttonRef,
    hiddenInput: hiddenInputRef,
    highlightedOption: highlightedOptionRef,
    input: inputRef,
    list: listRef,
    popover: popoverRef,
    selectedOption: selectedOptionRef
  }, DEBUG),
      state = _useMachine[0],
      send = _useMachine[1]; // IDs for aria attributes


  var _id = useId(props.id);

  var id = props.id || makeId("listbox-input", _id);
  var ref = useForkedRef(inputRef, forwardedRef); // If the button has children, we just render them as the label.
  // Otherwise we'll find the option with a value that matches the listbox value
  // and use its label in the button. We'll get that here and send it to the
  // button via context.
  // If a user needs the label for SSR to prevent hydration mismatch issues,
  // they need to control the state of the component and pass a label directly
  // to the button.

  var valueLabel = useMemo(function () {
    var selected = options.find(function (option) {
      return option.value === state.context.value;
    });
    return selected ? selected.label : null;
  }, [options, state.context.value]);
  var isExpanded = isListboxExpanded(state.value); // TODO: Remove duplication and memoize

  var context = useMemo(function () {
    return {
      ariaLabel: ariaLabel,
      ariaLabelledBy: ariaLabelledBy,
      disabled: disabled,
      isExpanded: isExpanded,
      listboxId: id,
      listboxValueLabel: valueLabel,
      onValueChange: onChange,
      buttonRef: buttonRef,
      listRef: listRef,
      popoverRef: popoverRef,
      selectedOptionRef: selectedOptionRef,
      highlightedOptionRef: highlightedOptionRef,
      send: send,
      state: state.value,
      stateData: state.context
    };
  }, [ariaLabel, ariaLabelledBy, state.value, state.context, disabled, id, isExpanded, onChange, send, valueLabel]); // For uncontrolled listbox components where no `defaultValue` is provided, we
  // will update the value based on the value of the first selectable option.
  // We call the update directly because:
  //   A) we only ever need to do this once, so we can guard with a ref
  //   B) useLayoutEffect races useDecendant, so we might not have options yet
  //   C) useEffect will cause a flash

  var mounted = useRef(false);

  if (!isControlled.current && // the app is not controlling state
  defaultValue == null && // there is no default value
  !mounted.current && // we haven't done this already
  options.length // we have some options
  ) {
      mounted.current = true;
      var first = options.find(function (option) {
        return !option.disabled;
      });

      if (first && first.value) {
        send({
          type: ListboxEvents.ValueChange,
          value: first.value
        });
      }
    }

  useControlledSwitchWarning(valueProp, "value", _componentName); // Even if the app controls state, we still need to update it internally to
  // run the state machine transitions

  useControlledStateSync(valueProp, state.context.value, function () {
    send({
      type: ListboxEvents.ValueChange,
      value: valueProp
    });
  });
  useIsomorphicLayoutEffect(function () {
    send({
      type: ListboxEvents.GetDerivedData,
      data: {
        options: options
      }
    });
  }, [options, send]);
  useEffect(function () {
    function handleMouseDown(event) {
      var target = event.target,
          relatedTarget = event.relatedTarget;

      if (!targetIsInPopover(target, popoverRef.current)) {
        send({
          type: ListboxEvents.OutsideMouseDown,
          relatedTarget: relatedTarget || target
        });
      }
    }

    if (isExpanded) {
      window.addEventListener("mousedown", handleMouseDown);
    }

    return function () {
      window.removeEventListener("mousedown", handleMouseDown);
    };
  }, [send, isExpanded]);
  useEffect(function () {
    function handleMouseUp(event) {
      var target = event.target,
          relatedTarget = event.relatedTarget;

      if (!targetIsInPopover(target, popoverRef.current)) {
        send({
          type: ListboxEvents.OutsideMouseUp,
          relatedTarget: relatedTarget || target
        });
      }
    }

    if (isExpanded) {
      window.addEventListener("mouseup", handleMouseUp);
    }

    return function () {
      window.removeEventListener("mouseup", handleMouseUp);
    };
  }, [send, isExpanded]);
  useCheckStyles("listbox");
  return React.createElement(DescendantProvider, {
    context: ListboxDescendantContext,
    items: options,
    set: setOptions
  }, React.createElement(ListboxContext.Provider, {
    value: context
  }, React.createElement("div", Object.assign({}, props, {
    ref: ref,
    "data-reach-listbox-input": "",
    "data-state": isExpanded ? "expanded" : "closed",
    "data-value": state.context.value,
    id: id
  }), isFunction(children) ? children({
    id: id,
    isExpanded: isExpanded,
    value: state.context.value,
    selectedOptionRef: selectedOptionRef,
    highlightedOptionRef: highlightedOptionRef,
    valueLabel: valueLabel,
    // TODO: Remove in 1.0
    expanded: isExpanded
  }) : children), (form || name || required) && React.createElement("input", {
    ref: hiddenInputRef,
    "data-reach-listbox-hidden-input": "",
    disabled: disabled,
    form: form,
    name: name,
    readOnly: true,
    required: required,
    tabIndex: -1,
    type: "hidden",
    value: state.context.value || ""
  })));
});

if (process.env.NODE_ENV !== "production") {
  ListboxInput.displayName = "ListboxInput";
  ListboxInput.propTypes = {
    children: /*#__PURE__*/PropTypes.oneOfType([PropTypes.node, PropTypes.func]),
    defaultValue: PropTypes.string,
    disabled: PropTypes.bool,
    form: PropTypes.string,
    name: PropTypes.string,
    onChange: PropTypes.func,
    required: PropTypes.bool,
    value: PropTypes.string
  };
} ////////////////////////////////////////////////////////////////////////////////

/**
 * Listbox
 *
 * High-level listbox API
 *
 * @example
 * <Listbox>
 *   <ListboxOption value="1">Option 1</ListboxOption>
 *   <ListboxOption value="2">Option 2</ListboxOption>
 *   <ListboxOption value="3">Option 3</ListboxOption>
 * </Listbox>
 *
 * @see Docs https://reach.tech/listbox#listbox-1
 */


var Listbox = /*#__PURE__*/forwardRef(function Listbox(_ref2, forwardedRef) {
  var _ref2$arrow = _ref2.arrow,
      arrow = _ref2$arrow === void 0 ? "â–¼" : _ref2$arrow,
      button = _ref2.button,
      children = _ref2.children,
      _ref2$portal = _ref2.portal,
      portal = _ref2$portal === void 0 ? true : _ref2$portal,
      props = _objectWithoutPropertiesLoose(_ref2, ["arrow", "button", "children", "portal"]);

  return React.createElement(ListboxInput, Object.assign({}, props, {
    _componentName: "Listbox",
    ref: forwardedRef
  }), function (_ref3) {
    var value = _ref3.value,
        valueLabel = _ref3.valueLabel;
    return React.createElement(Fragment, null, React.createElement(ListboxButton, {
      arrow: arrow,
      children: button ? isFunction(button) ? button({
        value: value,
        label: valueLabel
      }) : button : undefined
    }), React.createElement(ListboxPopover, {
      portal: portal
    }, React.createElement(ListboxList, null, children)));
  });
});

if (process.env.NODE_ENV !== "production") {
  Listbox.displayName = "Listbox";
  Listbox.propTypes = /*#__PURE__*/_extends({}, ListboxInput.propTypes, {
    arrow: /*#__PURE__*/PropTypes.oneOfType([PropTypes.node, PropTypes.bool]),
    button: /*#__PURE__*/PropTypes.oneOfType([PropTypes.func, PropTypes.node]),
    children: PropTypes.node
  });
} ////////////////////////////////////////////////////////////////////////////////

/**
 * ListboxButton
 *
 * The interactive toggle button that triggers the popover for the listbox.
 *
 * @see Docs https://reach.tech/listbox#listbox-button
 */


var ListboxButtonImpl = /*#__PURE__*/forwardRefWithAs(function ListboxButton(_ref4, forwardedRef) {
  var ariaLabel = _ref4["aria-label"],
      _ref4$arrow = _ref4.arrow,
      arrow = _ref4$arrow === void 0 ? false : _ref4$arrow,
      _ref4$as = _ref4.as,
      Comp = _ref4$as === void 0 ? "span" : _ref4$as,
      children = _ref4.children,
      onKeyDown = _ref4.onKeyDown,
      onMouseDown = _ref4.onMouseDown,
      onMouseUp = _ref4.onMouseUp,
      props = _objectWithoutPropertiesLoose(_ref4, ["aria-label", "arrow", "as", "children", "onKeyDown", "onMouseDown", "onMouseUp"]);

  var _useContext = useContext(ListboxContext),
      ariaLabelledBy = _useContext.ariaLabelledBy,
      buttonRef = _useContext.buttonRef,
      disabled = _useContext.disabled,
      isExpanded = _useContext.isExpanded,
      listboxId = _useContext.listboxId,
      stateData = _useContext.stateData,
      send = _useContext.send,
      listboxValueLabel = _useContext.listboxValueLabel;

  var listboxValue = stateData.value;
  var ref = useForkedRef(buttonRef, forwardedRef);
  var handleKeyDown = useKeyDown();

  function handleMouseDown(event) {
    if (!isRightClick(event.nativeEvent)) {
      event.preventDefault();
      event.stopPropagation();
      send({
        type: ListboxEvents.ButtonMouseDown,
        disabled: disabled
      });
    }
  }

  function handleMouseUp(event) {
    if (!isRightClick(event.nativeEvent)) {
      event.preventDefault();
      event.stopPropagation();
      send({
        type: ListboxEvents.ButtonMouseUp
      });
    }
  }

  var id = makeId("button", listboxId); // If the button has children, we just render them as the label
  // If a user needs the label on the server to prevent hydration mismatch
  // errors, they need to control the state of the component and pass a label
  // directly to the button.

  var label = useMemo(function () {
    if (!children) {
      return listboxValueLabel;
    } else if (isFunction(children)) {
      return children({
        isExpanded: isExpanded,
        label: listboxValueLabel,
        value: listboxValue,
        // TODO: Remove in 1.0
        expanded: isExpanded
      });
    }

    return children;
  }, [children, listboxValueLabel, isExpanded, listboxValue]);
  return React.createElement(Comp // Applicable to all host language elements regardless of whether a
  // `role` is applied.
  // https://www.w3.org/WAI/PF/aria/states_and_properties#global_states_header
  , Object.assign({
    "aria-disabled": disabled || undefined,
    "aria-expanded": isExpanded || undefined,
    "aria-haspopup": "listbox",
    "aria-labelledby": ariaLabel ? undefined : [ariaLabelledBy, id].filter(Boolean).join(" "),
    "aria-label": ariaLabel,
    // Identifies the element as a button widget.
    // https://www.w3.org/TR/wai-aria-practices-1.2/examples/button/button.html
    role: "button",
    // Includes the element in the tab sequence.
    // https://www.w3.org/TR/wai-aria-practices-1.2/examples/button/button.html
    tabIndex: disabled ? -1 : 0
  }, props, {
    ref: ref,
    "data-reach-listbox-button": "",
    id: id,
    onKeyDown: wrapEvent(onKeyDown, handleKeyDown),
    onMouseDown: wrapEvent(onMouseDown, handleMouseDown),
    onMouseUp: wrapEvent(onMouseUp, handleMouseUp)
  }), label, arrow && React.createElement(ListboxArrow, null, isBoolean(arrow) ? null : arrow));
});

if (process.env.NODE_ENV !== "production") {
  ListboxButtonImpl.displayName = "ListboxButton";
  ListboxButtonImpl.propTypes = {
    arrow: /*#__PURE__*/PropTypes.oneOfType([PropTypes.node, PropTypes.bool]),
    children: /*#__PURE__*/PropTypes.oneOfType([PropTypes.node, PropTypes.func])
  };
}

var ListboxButton = /*#__PURE__*/memoWithAs(ListboxButtonImpl); ////////////////////////////////////////////////////////////////////////////////

/**
 * ListboxArrow
 *
 * A wrapper component for an arrow to display in the `ListboxButton`
 *
 * @see Docs https://reach.tech/listbox#listboxarrow
 */

var ListboxArrowImpl = /*#__PURE__*/forwardRef(function ListboxArrow(_ref5, forwardedRef) {
  var children = _ref5.children,
      props = _objectWithoutPropertiesLoose(_ref5, ["children"]);

  var _useContext2 = useContext(ListboxContext),
      isExpanded = _useContext2.isExpanded;

  return React.createElement("span", Object.assign({
    "aria-hidden": true
  }, props, {
    ref: forwardedRef,
    "data-reach-listbox-arrow": "",
    "data-expanded": isExpanded ? "" : undefined
  }), isFunction(children) ? children({
    isExpanded: isExpanded,
    // TODO: Remove in 1.0
    expanded: isExpanded
  }) : children || "â–¼");
});

if (process.env.NODE_ENV !== "production") {
  ListboxArrowImpl.displayName = "ListboxArrow";
  ListboxArrowImpl.propTypes = {
    children: /*#__PURE__*/PropTypes.oneOfType([PropTypes.node, PropTypes.func])
  };
}

var ListboxArrow = /*#__PURE__*/memo(ListboxArrowImpl); ////////////////////////////////////////////////////////////////////////////////

/**
 * ListboxPopover
 *
 * The popover containing the list of options.
 *
 * @see Docs https://reach.tech/listbox#listboxpopover
 */

var ListboxPopoverImpl = /*#__PURE__*/forwardRef(function ListboxPopover(_ref6, forwardedRef) {
  var _ref6$position = _ref6.position,
      position = _ref6$position === void 0 ? positionMatchWidth : _ref6$position,
      onBlur = _ref6.onBlur,
      onKeyDown = _ref6.onKeyDown,
      _ref6$portal = _ref6.portal,
      portal = _ref6$portal === void 0 ? true : _ref6$portal,
      unstable_observableRefs = _ref6.unstable_observableRefs,
      props = _objectWithoutPropertiesLoose(_ref6, ["position", "onBlur", "onKeyDown", "portal", "unstable_observableRefs"]);

  var _useContext3 = useContext(ListboxContext),
      buttonRef = _useContext3.buttonRef,
      popoverRef = _useContext3.popoverRef,
      send = _useContext3.send,
      isExpanded = _useContext3.isExpanded;

  var ref = useForkedRef(popoverRef, forwardedRef);
  var handleKeyDown = useKeyDown();

  var commonProps = _extends({
    hidden: !isExpanded,
    tabIndex: -1
  }, props, {
    ref: ref,
    "data-reach-listbox-popover": "",
    onBlur: wrapEvent(onBlur, handleBlur),
    onKeyDown: wrapEvent(onKeyDown, handleKeyDown)
  });

  function handleBlur(event) {
    var nativeEvent = event.nativeEvent;
    requestAnimationFrame(function () {
      send({
        type: ListboxEvents.Blur,
        relatedTarget: nativeEvent.relatedTarget || nativeEvent.target
      });
    });
  }

  return portal ? React.createElement(Popover, Object.assign({}, commonProps, {
    targetRef: buttonRef,
    position: position,
    unstable_observableRefs: unstable_observableRefs
  })) : React.createElement("div", Object.assign({}, commonProps));
});

if (process.env.NODE_ENV !== "production") {
  ListboxPopoverImpl.displayName = "ListboxPopover";
  ListboxPopoverImpl.propTypes = {
    children: PropTypes.node.isRequired,
    portal: PropTypes.bool,
    position: PropTypes.func
  };
}

var ListboxPopover = /*#__PURE__*/memo(ListboxPopoverImpl); ////////////////////////////////////////////////////////////////////////////////

/**
 * ListboxList
 *
 * The list containing all listbox options.
 *
 * @see Docs https://reach.tech/listbox#listboxlist
 */

var ListboxList = /*#__PURE__*/forwardRefWithAs(function ListboxList(_ref7, forwardedRef) {
  var _ref7$as = _ref7.as,
      Comp = _ref7$as === void 0 ? "ul" : _ref7$as,
      props = _objectWithoutPropertiesLoose(_ref7, ["as"]);

  var _useContext4 = useContext(ListboxContext),
      ariaLabel = _useContext4.ariaLabel,
      ariaLabelledBy = _useContext4.ariaLabelledBy,
      isExpanded = _useContext4.isExpanded,
      listboxId = _useContext4.listboxId,
      listRef = _useContext4.listRef,
      _useContext4$stateDat = _useContext4.stateData,
      value = _useContext4$stateDat.value,
      navigationValue = _useContext4$stateDat.navigationValue;

  var ref = useForkedRef(forwardedRef, listRef);
  return React.createElement(Comp // Tells assistive technologies which of the options, if any, is
  // visually indicated as having keyboard focus. DOM focus remains on the
  // `ul` element and the idref specified for `aria-activedescendant`
  // refers to the `li` element that is visually styled as focused. When
  // navigation keys, such as `Down Arrow`, are pressed, the JavaScript
  // changes the value.
  // https://www.w3.org/TR/wai-aria-practices-1.2/examples/listbox/listbox-grouped.html
  , Object.assign({
    "aria-activedescendant": useOptionId(isExpanded ? navigationValue : value),
    "aria-labelledby": ariaLabel ? undefined : ariaLabelledBy,
    "aria-label": ariaLabel,
    // An element that contains or owns all the listbox options has role
    // listbox.
    // https://www.w3.org/TR/wai-aria-practices-1.2/#Listbox
    role: "listbox",
    // https://www.w3.org/TR/wai-aria-practices-1.2/examples/listbox/listbox-collapsible.html
    tabIndex: -1
  }, props, {
    ref: ref,
    "data-reach-listbox-list": "",
    id: makeId("listbox", listboxId)
  }));
});

if (process.env.NODE_ENV !== "production") {
  ListboxList.displayName = "ListboxList";
  ListboxList.propTypes = {};
} ////////////////////////////////////////////////////////////////////////////////

/**
 * ListboxOption
 *
 * A selectable option for the listbox.
 *
 * @see Docs https://reach.tech/listbox#listboxoption
 */


var ListboxOption = /*#__PURE__*/forwardRefWithAs(function ListboxOption(_ref8, forwardedRef) {
  var _ref8$as = _ref8.as,
      Comp = _ref8$as === void 0 ? "li" : _ref8$as,
      children = _ref8.children,
      disabled = _ref8.disabled,
      onMouseDown = _ref8.onMouseDown,
      onMouseEnter = _ref8.onMouseEnter,
      onMouseLeave = _ref8.onMouseLeave,
      onMouseMove = _ref8.onMouseMove,
      onMouseUp = _ref8.onMouseUp,
      onTouchStart = _ref8.onTouchStart,
      value = _ref8.value,
      labelProp = _ref8.label,
      props = _objectWithoutPropertiesLoose(_ref8, ["as", "children", "disabled", "onMouseDown", "onMouseEnter", "onMouseLeave", "onMouseMove", "onMouseUp", "onTouchStart", "value", "label"]);

  if (process.env.NODE_ENV !== "production" && !value) {
    throw Error("A ListboxOption must have a value prop.");
  }

  var _useContext5 = useContext(ListboxContext),
      highlightedOptionRef = _useContext5.highlightedOptionRef,
      isExpanded = _useContext5.isExpanded,
      onValueChange = _useContext5.onValueChange,
      selectedOptionRef = _useContext5.selectedOptionRef,
      send = _useContext5.send,
      state = _useContext5.state,
      _useContext5$stateDat = _useContext5.stateData,
      listboxValue = _useContext5$stateDat.value,
      navigationValue = _useContext5$stateDat.navigationValue;

  var _useState = useState(labelProp),
      labelState = _useState[0],
      setLabel = _useState[1];

  var label = labelProp || labelState || "";
  var ownRef = useRef(null);
  useDescendant({
    element: ownRef.current,
    value: value,
    label: label,
    disabled: !!disabled
  }, ListboxDescendantContext); // After the ref is mounted to the DOM node, we check to see if we have an
  // explicit label prop before looking for the node's textContent for
  // typeahead functionality.

  var getLabelFromDomNode = useCallback(function (node) {
    if (!labelProp && node) {
      setLabel(function (prevState) {
        if (node.textContent && prevState !== node.textContent) {
          return node.textContent;
        }

        return prevState || "";
      });
    }
  }, [labelProp]);
  var isHighlighted = navigationValue ? navigationValue === value : false;
  var isSelected = listboxValue === value;
  var ref = useForkedRef(getLabelFromDomNode, forwardedRef, ownRef, isSelected ? selectedOptionRef : null, isHighlighted ? highlightedOptionRef : null);

  function handleMouseEnter() {
    send({
      type: ListboxEvents.OptionMouseEnter,
      value: value,
      disabled: !!disabled
    });
  }

  function handleTouchStart() {
    send({
      type: ListboxEvents.OptionTouchStart,
      value: value,
      disabled: !!disabled
    });
  }

  function handleMouseLeave() {
    send({
      type: ListboxEvents.ClearNavSelection
    });
  }

  function handleMouseDown(event) {
    // Prevent blur event from firing and bubbling to the popover
    if (!isRightClick(event.nativeEvent)) {
      event.preventDefault();
      send({
        type: ListboxEvents.OptionMouseDown
      });
    }
  }

  function handleMouseUp(event) {
    if (!isRightClick(event.nativeEvent)) {
      send({
        type: ListboxEvents.OptionMouseUp,
        value: value,
        callback: onValueChange,
        disabled: !!disabled
      });
    }
  }

  function handleMouseMove() {
    // We don't really *need* these guards since we put all of our transition
    // logic in the state machine, but in this case it seems wise not to
    // needlessly run our transitions every time the user's mouse moves. Seems
    // like a lot. ðŸ™ƒ
    if (state === ListboxStates.Open || navigationValue !== value) {
      send({
        type: ListboxEvents.OptionMouseMove,
        value: value,
        disabled: !!disabled
      });
    }
  }

  return React.createElement(Comp // In a single-select listbox, the selected option has `aria-selected`
  // set to `true`.
  // https://www.w3.org/TR/wai-aria-practices-1.2/#Listbox
  , Object.assign({
    "aria-selected": (isExpanded ? isHighlighted : isSelected) || undefined,
    "aria-disabled": disabled || undefined,
    // Each option in the listbox has role `option` and is a DOM descendant
    // of the element with role `listbox`.
    // https://www.w3.org/TR/wai-aria-practices-1.2/#Listbox
    role: "option"
  }, props, {
    ref: ref,
    id: useOptionId(value),
    "data-reach-listbox-option": "",
    "data-current": isSelected ? "" : undefined,
    "data-label": label,
    "data-value": value,
    onMouseDown: wrapEvent(onMouseDown, handleMouseDown),
    onMouseEnter: wrapEvent(onMouseEnter, handleMouseEnter),
    onMouseLeave: wrapEvent(onMouseLeave, handleMouseLeave),
    onMouseMove: wrapEvent(onMouseMove, handleMouseMove),
    onMouseUp: wrapEvent(onMouseUp, handleMouseUp),
    onTouchStart: wrapEvent(onTouchStart, handleTouchStart)
  }), children);
});

if (process.env.NODE_ENV !== "production") {
  ListboxOption.displayName = "ListboxOption";
  ListboxOption.propTypes = {
    disabled: PropTypes.bool,
    label: PropTypes.string,
    value: PropTypes.string.isRequired
  };
} ////////////////////////////////////////////////////////////////////////////////

/**
 * ListboxGroup
 *
 * A group of related listbox options.
 *
 * @see Docs https://reach.tech/listbox#listboxgroup
 */


var ListboxGroup = /*#__PURE__*/forwardRef(function ListboxGroup(_ref9, forwardedRef) {
  var label = _ref9.label,
      children = _ref9.children,
      props = _objectWithoutPropertiesLoose(_ref9, ["label", "children"]);

  var _useContext6 = useContext(ListboxContext),
      listboxId = _useContext6.listboxId;

  var labelId = makeId("label", useId(props.id), listboxId);
  return React.createElement(ListboxGroupContext.Provider, {
    value: {
      labelId: labelId
    }
  }, React.createElement("div", Object.assign({
    "aria-labelledby": labelId,
    // Identifies a group of related options
    // https://www.w3.org/TR/wai-aria-practices-1.2/examples/listbox/listbox-grouped.html
    role: "group"
  }, props, {
    "data-reach-listbox-group": "",
    ref: forwardedRef
  }), label && React.createElement(ListboxGroupLabel, null, label), children));
});

if (process.env.NODE_ENV !== "production") {
  ListboxGroup.displayName = "ListboxGroup";
  ListboxGroup.propTypes = {
    label: /*#__PURE__*/PropTypes.oneOfType([PropTypes.string, PropTypes.element])
  };
} ////////////////////////////////////////////////////////////////////////////////

/**
 * ListboxGroupLabel
 *
 * @see Docs https://reach.tech/listbox#listboxgrouplabel
 */


var ListboxGroupLabel = /*#__PURE__*/forwardRefWithAs(function ListboxGroupLabel(_ref10, forwardedRef) {
  var _ref10$as = _ref10.as,
      Comp = _ref10$as === void 0 ? "span" : _ref10$as,
      props = _objectWithoutPropertiesLoose(_ref10, ["as"]);

  var _useContext7 = useContext(ListboxGroupContext),
      labelId = _useContext7.labelId;

  return React.createElement(Comp // See examples
  // https://www.w3.org/TR/wai-aria-practices-1.2/examples/listbox/listbox-grouped.html
  , Object.assign({
    // See examples
    // https://www.w3.org/TR/wai-aria-practices-1.2/examples/listbox/listbox-grouped.html
    role: "presentation"
  }, props, {
    ref: forwardedRef,
    "data-reach-listbox-group-label": "",
    id: labelId
  }));
});

if (process.env.NODE_ENV !== "production") {
  ListboxGroupLabel.displayName = "ListboxGroupLabel";
  ListboxGroupLabel.propTypes = {};
} ////////////////////////////////////////////////////////////////////////////////

/**
 * A hook that exposes data for a given `Listbox` component to its descendants.
 *
 * @see Docs https://reach.tech/listbox#uselistboxcontext
 */


function useListboxContext() {
  var _useContext8 = useContext(ListboxContext),
      highlightedOptionRef = _useContext8.highlightedOptionRef,
      listboxId = _useContext8.listboxId,
      listboxValueLabel = _useContext8.listboxValueLabel,
      isExpanded = _useContext8.isExpanded,
      selectedOptionRef = _useContext8.selectedOptionRef,
      value = _useContext8.stateData.value;

  return useMemo(function () {
    return {
      id: listboxId,
      isExpanded: isExpanded,
      selectedOptionRef: selectedOptionRef,
      highlightedOptionRef: highlightedOptionRef,
      value: value,
      valueLabel: listboxValueLabel
    };
  }, [listboxId, isExpanded, value, listboxValueLabel, selectedOptionRef, highlightedOptionRef]);
} ////////////////////////////////////////////////////////////////////////////////

function isListboxExpanded(state) {
  return [ListboxStates.Navigating, ListboxStates.Open, ListboxStates.Dragging, ListboxStates.Interacting].includes(state);
}

function useKeyDown() {
  var _useContext9 = useContext(ListboxContext),
      listboxDisabled = _useContext9.disabled,
      onValueChange = _useContext9.onValueChange,
      _useContext9$stateDat = _useContext9.stateData,
      navigationValue = _useContext9$stateDat.navigationValue,
      typeaheadQuery = _useContext9$stateDat.typeaheadQuery,
      send = _useContext9.send;

  var options = useDescendants(ListboxDescendantContext);
  useEffect(function () {
    if (typeaheadQuery) {
      send({
        type: ListboxEvents.UpdateAfterTypeahead,
        query: typeaheadQuery,
        callback: onValueChange
      });
    }

    var timeout = window.setTimeout(function () {
      if (typeaheadQuery != null) {
        send({
          type: ListboxEvents.ClearTypeahead
        });
      }
    }, 1000);
    return function () {
      window.clearTimeout(timeout);
    };
  }, [onValueChange, send, typeaheadQuery]);
  var index = options.findIndex(function (_ref11) {
    var value = _ref11.value;
    return value === navigationValue;
  });
  var handleKeyDown = wrapEvent(function (event) {
    var key = event.key;
    var isSearching = isString(key) && key.length === 1;
    var navOption = options.find(function (option) {
      return option.value === navigationValue;
    });

    switch (key) {
      case "Enter":
        send({
          type: ListboxEvents.KeyDownEnter,
          value: navigationValue,
          callback: onValueChange,
          disabled: !!((navOption === null || navOption === void 0 ? void 0 : navOption.disabled) || listboxDisabled)
        });
        return;

      case " ":
        // Prevent browser from scrolling down
        event.preventDefault();
        send({
          type: ListboxEvents.KeyDownSpace,
          value: navigationValue,
          callback: onValueChange,
          disabled: !!((navOption === null || navOption === void 0 ? void 0 : navOption.disabled) || listboxDisabled)
        });
        return;

      case "Escape":
        send({
          type: ListboxEvents.KeyDownEscape
        });
        return;

      case "Tab":
        var eventType = event.shiftKey ? ListboxEvents.KeyDownShiftTab : ListboxEvents.KeyDownTab;
        send({
          type: eventType
        });
        return;

      default:
        if (isSearching) {
          send({
            type: ListboxEvents.KeyDownSearch,
            query: key,
            disabled: listboxDisabled
          });
        }

        return;
    }
  }, useDescendantKeyDown(ListboxDescendantContext, {
    currentIndex: index,
    orientation: "vertical",
    key: "index",
    rotate: true,
    filter: function filter(option) {
      return !option.disabled;
    },
    callback: function callback(nextIndex) {
      send({
        type: ListboxEvents.KeyDownNavigate,
        value: options[nextIndex].value,
        disabled: listboxDisabled
      });
    }
  }));
  return handleKeyDown;
}

function useOptionId(value) {
  var _useContext10 = useContext(ListboxContext),
      listboxId = _useContext10.listboxId;

  return value ? makeId("option-" + value, listboxId) : undefined;
}

function targetIsInPopover(element, popover) {
  return !!(element === popover || (popover === null || popover === void 0 ? void 0 : popover.contains(element)));
}

function useControlledStateSync(controlPropValue, internalValue, send) {
  var _useRef = useRef(controlPropValue != null),
      isControlled = _useRef.current;

  if (isControlled && controlPropValue !== internalValue) {
    send();
  }
}

export { Listbox, ListboxArrow, ListboxButton, ListboxGroup, ListboxGroupLabel, ListboxInput, ListboxList, ListboxOption, ListboxPopover, useListboxContext };
//# sourceMappingURL=listbox.esm.js.map
